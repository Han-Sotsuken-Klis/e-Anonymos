# -*- coding: utf-8 -*-
"""ÂçíÊ•≠Á†îÁ©∂e.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AznzcHA94nyu7TSFtpU3ItoxaFLL3u28
"""

print('Hello World')

from google.colab import drive
drive.mount("/content/gdrive")

pip install pillow

#!/usr/bin/python3
import sys
import glob
import os
import csv
import json
from PIL import Image
import subprocess # For running git commands
from google.colab import userdata # To access Colab secrets

# --- GitHub Configuration ---
# IMPORTANT: Store your GitHub Personal Access Token in Colab Secrets
# under the name 'GITHUB_TOKEN'.
# Go to the 'üîë' icon on the left sidebar, click 'Add a new secret',
# set Name as 'GITHUB_TOKEN' and Value as your token.
# Make sure to enable "Notebook access to this secret".
try:
    GITHUB_TOKEN = userdata.get('GITHUB_TOKEN')
except userdata.SecretNotFoundError:
    print("Error: GitHub Token not found in Colab Secrets.")
    print("Please add your token under the name 'GITHUB_TOKEN' in the Secrets panel.")
    # Exit or handle the error appropriately
    sys.exit(1)

# Replace with your GitHub username and repository name
github_username = 'Han-Sotsuken-Klis' # <--- CHANGE THIS
github_repo_name = 'e-Anonymos' # <--- CHANGE THIS
github_branch = 'main' # <--- CHANGE THIS if not 'main'

# Construct the repository URL with the token for cloning
github_repo_url = f'https://{github_username}:{GITHUB_TOKEN}@github.com/{github_username}/{github_repo_name}.git'
local_repo_path = '/content/github_repo'

# Clone the GitHub repository
if os.path.exists(local_repo_path):
    print(f"Repository already exists at {local_repo_path}. Pulling latest changes.")
    try:
        subprocess.run(['git', '-C', local_repo_path, 'pull', 'origin', github_branch], check=True)
    except subprocess.CalledProcessError as e:
        print(f"Error pulling changes from GitHub: {e}")
        sys.exit(1)
else:
    print(f"Cloning repository {github_username}/{github_repo_name}...")
    try:
        subprocess.run(['git', 'clone', '--branch', github_branch, github_repo_url, local_repo_path], check=True)
    except subprocess.CalledProcessError as e:
        print(f"Error cloning repository from GitHub: {e}")
        print("Please check your GitHub username, repository name, branch, and Personal Access Token.")
        sys.exit(1)

print("Repository cloned/pulled successfully.")

# --- File Paths (relative to the cloned repository) ---
# Specify the path to your CSV file within the cloned repository
csv_file_path_relative = 'manifest-e-Anonymos.csv' # <--- CHANGE THIS TO YOUR CSV FILE PATH RELATIVE TO REPO ROOT
csv_file_path = os.path.join(local_repo_path, csv_file_path_relative)

# The base URL for the manifest and images when hosted (e.g., GitHub Pages)
# Replace with your GitHub Pages URL or other hosting URL
base_url = f'https://{github_username}.github.io/{github_repo_name}/' # <--- CHANGE THIS
# Replace with your IIIF Image API base URL for images hosted on GitHub Pages
# If using a service like iiif.io/tools/image-server, this will be different
# For simple hosting on GitHub Pages, the image URL will just be the raw file URL.
# A dedicated IIIF Image Server is needed for full IIIF Image API compliance.
# For this example, we'll construct URLs based on the hosted location.
# CHANGE: Use GitHub Pages URL for images as well for Level 0 compatibility
base_image_url = base_url # <--- MODIFIED: Use base_url for images


# Dictionary to store metadata for each image file path
image_metadata = {}
bib_title = []

# These keys are typically used at the Manifest level, but we'll also check if they are present in Canvas metadata in CSV
manifest_level_keys = ['dir', 'title', 'license', 'attribution', 'within', 'logo', 'description', 'viewingHint', 'viewingDirection']

# Dictionary to store potential manifest-level information from the first data row
manifest_level_data = {} # Store manifest-level data directly

# --- Read CSV File ---
if not os.path.exists(csv_file_path):
    print(f"Error: CSV file not found at {csv_file_path}")
    sys.exit(1)

with open(csv_file_path, newline='', encoding='utf_8_sig') as csvfile:
  spamreader = csv.reader(csvfile, delimiter=',', quotechar='"')
  rn = 0
  for row in spamreader:
    if rn == 0:
      # Store header row for metadata labels
      bib_title = row
    else:
      # Added check for empty row or row with insufficient columns
      if not row or len(row) < 1 or not row[0].strip(): # Also check if the first column is empty
          print(f"Skipping empty or invalid row {rn + 1} in CSV.")
          continue

      # If this is the first data row, store it as potential manifest-level data
      if rn == 1:
           for i in range(1, len(row)): # Start from 1 to skip the image path column
               if i < len(bib_title):
                   header = bib_title[i]
                   value = row[i]
                   manifest_level_data[header] = value


      # Assuming the first column is the image file path relative to the repository root
      image_file_path_relative_from_csv = row[0].strip() # Use strip to remove leading/trailing whitespace
      # Construct the full local path to the image file by joining local_repo_path with the relative path from CSV
      image_file_path = os.path.join(local_repo_path, image_file_path_relative_from_csv)

      # Store metadata for this image file path (using the full local path as the key)
      image_metadata[image_file_path] = {}
      for i in range(1, len(row)):
          # Added check for column existence to prevent IndexError
          if i < len(bib_title):
              header = bib_title[i]
              value = row[i]
              # Store all subsequent columns as metadata for the image path
              image_metadata[image_file_path][header] = value
          else:
              print(f"Warning: Header for column {i} not found in CSV header row.")

    rn = rn + 1

# Extract unique directories from the image file paths in the CSV that have file entries
manifest_dirs = set()
for img_path in image_metadata.keys():
    # Check if the key is a file path within the local repo AND the file actually exists
    if os.path.isfile(img_path) and img_path.startswith(local_repo_path):
        manifest_dirs.add(os.path.dirname(img_path))


print(f"\nDirectories found in CSV for manifest creation: {list(manifest_dirs)}")


# --- Generate Manifest ---
# Define the desired output path within the local repository
# Set the output path to the root of the cloned repository with the desired filename
output_manifest_filename = 'e-Anonymos-manifest.json'
output_manifest_path_local = os.path.join(local_repo_path, output_manifest_filename)


# Initialize manifest structure for the single output file
each_manifest = {}
all_meta_manifest = [] # Metadata specifically for the Manifest level
canvases = []
all_image_file_names_local = [] # Collect all image file paths from all directories

# Collect all image file paths from all directories found in CSV that have metadata entries
# Iterate through the keys in image_metadata, which are the local paths derived from the CSV
for img_path_local in image_metadata.keys():
     # Check if the file actually exists at this local path
     if os.path.isfile(img_path_local):
         all_image_file_names_local.append(img_path_local)

all_image_file_names_local.sort() # Sort the list of files

print(f"Found image files with associated CSV data: {all_image_file_names_local}")


# --- Populate Manifest-level Properties and Metadata from the first data row ---
for item, value in manifest_level_data.items():
    if value.strip(): # Only add if value is not empty or just whitespace
        if item in manifest_level_keys and item != 'dir':
             if item == 'title':
                 each_manifest['label'] = value # Use 'label' for Manifest title
             else:
                 each_manifest[item] = value
        # Add other columns from the first data row as Manifest metadata
        elif item != 'dir': # Avoid adding 'dir' itself to metadata
             each_meta_manifest  = {}
             each_meta_manifest['label'] = item
             each_meta_manifest['value'] = value
             all_meta_manifest.append(each_meta_manifest)


if all_meta_manifest:
    each_manifest['metadata'] = all_meta_manifest


# Set default Manifest properties if not found in manifest_level_data
# Construct @id using the base_url and the relative path for the single manifest file
output_manifest_path_relative = os.path.relpath(output_manifest_path_local, local_repo_path)
if '@id' not in each_manifest:
    each_manifest['@id'] = base_url + output_manifest_path_relative
if '@type' not in each_manifest:
    each_manifest['@type'] = 'sc:Manifest'
if '@context' not in each_manifest:
    each_manifest['@context'] = 'http://iiif.io/api/presentation/2/context.json'
if 'label' not in each_manifest:
     each_manifest['label'] = os.path.basename(output_manifest_path_local) # Use filename as default label


cn = 0
if not all_image_file_names_local:
    print("Warning: No image files found with associated CSV data. The manifest will contain an empty sequence.")
else:
    for file_path_local in all_image_file_names_local:
       # service = {} # Remove service block for Level 0
       resource = {}
       mani_image = {}
       canvas = {}
       canvas_metadata = [] # Metadata specifically for this Canvas

       # Collect metadata for this specific image (Canvas) from image_metadata dictionary
       if file_path_local in image_metadata:
           for item, value in image_metadata[file_path_local].items():
               if value.strip():
                   each_meta_canvas  = {}
                   each_meta_canvas['label'] = item
                   each_meta_canvas['value'] = value
                   canvas_metadata.append(each_meta_canvas)

       if canvas_metadata:
           canvas['metadata'] = canvas_metadata

       cn = cn + 1
       canvas_number = 'p'+str(cn)
       # Construct Canvas ID using base_url and a relative path for the canvas
       # Base the canvas ID on the directory of the image file, but relative to the repo root
       image_dir_relative = os.path.relpath(os.path.dirname(file_path_local), local_repo_path)
       # Modified: Use the output manifest's relative path as the base for canvas IDs if a single manifest is desired
       # This makes canvas IDs relative to the manifest location, which is common practice
       # Alternatively, keep them relative to the image location if that's preferred for IIIF Image API
       # Let's keep it relative to image location for now for consistency with potential Image API setup
       canvas_id = f"{base_url}{image_dir_relative}/canvas/{canvas_number}"


       # Get the relative path of the image file within the GitHub repo
       file_path_relative = os.path.relpath(file_path_local, local_repo_path)
       # Construct image URL ID using the base_image_url (now GitHub Pages URL) and the relative path of the image file
       # For Level 0, the resource @id is the direct image URL
       image_url_id = f"{base_image_url}{file_path_relative}"

       # Remove service block for Level 0
       # service['@context'] = 'http://iiif.io/api/image/2/context.json'
       # service['@id']  = image_url_id # The base URL for the image service (this is likely NOT a IIIF Image API service)
       # service['profile'] = 'http://iiif.io/api/image/2/level1.json' # This profile is for IIIF Image API, might not be accurate for raw files

       try:
           # Use the local file path to open the image to get dimensions
           img = Image.open(file_path_local)
           width, height = img.size
       except FileNotFoundError:
           print(f"Error: Image file not found at {file_path_local}. Skipping.")
           continue
       except Exception as e:
           print(f"Error opening image file {file_path_local}: {e}. Skipping.")
           continue

       resource['@type'] = 'dctypes:Image'
       # Set format based on the image file extension if possible, otherwise default to jpeg
       resource['format'] = f'image/{os.path.splitext(file_path_local)[1][1:].lower()}' if os.path.splitext(file_path_local)[1] else 'image/jpeg'
       resource['width'] = width
       resource['height'] = height
       # For Level 0, the resource @id is the direct image URL
       resource['@id'] = image_url_id
       # Remove service block for Level 0
       # resource['service'] = service

       mani_image['@type']  = 'oa:Annotation'
       mani_image['motivation']  = 'sc:painting'
       mani_image['resource']  = resource
       # Construct annotation ID
       mani_image['@id']  = f"{base_url}{image_dir_relative}/annotation/{canvas_number}"
       mani_image['on']  = canvas_id

       canvas_label = f'p. {cn}'
       if file_path_local in image_metadata and 'title' in image_metadata[file_path_local] and image_metadata[file_path_local]['title'].strip():
           canvas_label = image_metadata[file_path_local]['title']
       canvas['label'] = canvas_label

       canvas['images'] = []
       canvas['images'].append(mani_image)
       canvas['width'] = width
       canvas['height'] = height
       canvas['@type'] = 'sc:Canvas'
       canvas['@id'] = canvas_id
       canvases.append(canvas)


# Construct sequence for the single manifest
# Modified: Construct sequence ID relative to the manifest location
sequence = {} # Initialize the sequence dictionary
sequence_id = f"{base_url}{output_manifest_path_relative.rsplit('/', 1)[0]}/sequence/s1" if '/' in output_manifest_path_relative else f"{base_url}sequence/s1"
sequence['@id'] =  sequence_id
sequence['@type'] =  'sc:Sequence'
sequence['label'] =  'Current Page Order'
sequence['canvases'] = canvases
each_manifest['sequences'] = []
each_manifest['sequences'].append(sequence)

# Write the single manifest file to the specified local path
write_file_path_local = output_manifest_path_local
os.makedirs(os.path.dirname(write_file_path_local), exist_ok=True) # Ensure directory exists
with open(write_file_path_local, mode='w') as f:
  json.dump(each_manifest, f, ensure_ascii=False, indent=2)
print(f"Manifest file created locally at: {write_file_path_local}")

# --- GitHub Push ---
# Now, add, commit, and push the changes back to GitHub
print("\nAdding, committing, and pushing changes to GitHub...")
try:
    # Add the generated manifest files
    subprocess.run(['git', '-C', local_repo_path, 'add', '.'], check=True) # Add all changes

    # Commit the changes
    commit_message = "Update image URLs to GitHub Pages format for Level 0 manifest"
    # Added --allow-empty for debugging if commit still fails due to no perceived changes
    subprocess.run(['git', '-C', local_repo_path, 'commit', '-m', commit_message, '--allow-empty'], check=True)

    # Push the changes
    subprocess.run(['git', '-C', local_repo_path, 'push', 'origin', github_branch], check=True)

    print("Changes successfully pushed to GitHub.")

except subprocess.CalledProcessError as e:
    print(f"Error during git add, commit, or push: {e}")
    print("Please check your GitHub permissions and repository status.")